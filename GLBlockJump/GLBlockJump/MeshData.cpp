#include "MeshData.h"

const GLfloat cubeVertices[8][3] = {
    {  0.5f,  0.5f,  0.5f },   // 정점 0
    { -0.5f,  0.5f,  0.5f },   // 정점 1
    { -0.5f, -0.5f,  0.5f },   // 정점 2
    {  0.5f, -0.5f,  0.5f },   // 정점 3
    {  0.5f,  0.5f, -0.5f },   // 정점 4
    { -0.5f,  0.5f, -0.5f },   // 정점 5
    { -0.5f, -0.5f, -0.5f },   // 정점 6
    {  0.5f, -0.5f, -0.5f }    // 정점 7
};
const GLfloat cubeNormal[8][3] = {
    {  0.57735f,  0.57735f,  0.57735f },  // 정점 0
    { -0.57735f,  0.57735f,  0.57735f },  // 정점 1
    { -0.57735f, -0.57735f,  0.57735f },  // 정점 2
    {  0.57735f, -0.57735f,  0.57735f },  // 정점 3
    {  0.57735f,  0.57735f, -0.57735f },  // 정점 4
    { -0.57735f,  0.57735f, -0.57735f },  // 정점 5
    { -0.57735f, -0.57735f, -0.57735f },  // 정점 6
    {  0.57735f, -0.57735f, -0.57735f }   // 정점 7
};
const GLfloat cubeColors[8][3] = {
    { 1.0f, 1.0f, 1.0f },
    { 1.0f, 1.0f, 1.0f },
    { 1.0f, 1.0f, 1.0f },
    { 1.0f, 1.0f, 1.0f },
    { 1.0f, 1.0f, 1.0f },
    { 1.0f, 1.0f, 1.0f },
    { 1.0f, 1.0f, 1.0f },
    { 1.0f, 1.0f, 1.0f }
};
const GLfloat cubeTextures[8][2] = {
    { 0.0f, 1.0f },
    { 1.0f, 1.0f },
    { 1.0f, 0.0f },
    { 0.0f, 0.0f },
    { 1.0f, 1.0f },
    { 0.0f, 1.0f },
    { 0.0f, 0.0f },
    { 1.0f, 0.0f }
};

const GLfloat lightbeamVertices[8][3] = {
    {  2.5,  100.0f,  2.5 },   // 정점 0
    { -2.5,  100.0f,  2.5 },   // 정점 1
    { -2.5, -0.0f,  2.5 },   // 정점 2
    {  2.5, -0.0f,  2.5 },   // 정점 3
    {  2.5,  100.0f, -2.5 },   // 정점 4
    { -2.5,  100.0f, -2.5 },   // 정점 5
    { -2.5, -0.0f, -2.5 },   // 정점 6
    {  2.5, -0.0f, -2.5 }    // 정점 7
};
const GLfloat lightbeamNormal[8][3] = {
    {  0.707f,  0.0f,  0.707f },  // 정점 0
    { -0.707f,  0.0f,  0.707f },  // 정점 1
    { -0.707f,  0.0f,  0.707f },  // 정점 2
    {  0.707f,  0.0f,  0.707f },  // 정점 3
    {  0.707f,  0.0f, -0.707f },  // 정점 4
    { -0.707f,  0.0f, -0.707f },  // 정점 5
    { -0.707f,  0.0f, -0.707f },  // 정점 6
    {  0.707f,  0.0f, -0.707f }   // 정점 7
};

const GLfloat startlightbeamColors[8][4] = {
    { 0.0f, 1.0f, 0.0f, 0.3f },
    { 0.0f, 1.0f, 0.0f, 0.3f },
    { 0.0f, 1.0f, 0.0f, 0.3f },
    { 0.0f, 1.0f, 0.0f, 0.3f },
    { 0.0f, 1.0f, 0.0f, 0.3f },
    { 0.0f, 1.0f, 0.0f, 0.3f },
    { 0.0f, 1.0f, 0.0f, 0.3f },
    { 0.0f, 1.0f, 0.0f, 0.3f }
};
const GLfloat endlightbeamColors[8][4] = {
    { 1.0f, 0.0f, 0.0f, 0.3f },
    { 1.0f, 0.0f, 0.0f, 0.3f },
    { 1.0f, 0.0f, 0.0f, 0.3f },
    { 1.0f, 0.0f, 0.0f, 0.3f },
    { 1.0f, 0.0f, 0.0f, 0.3f },
    { 1.0f, 0.0f, 0.0f, 0.3f },
    { 1.0f, 0.0f, 0.0f, 0.3f },
    { 1.0f, 0.0f, 0.0f, 0.3f }
};
const GLfloat texlightbeam[8][2] = {
    { 0.0f, 1.0f },
    { 1.0f, 1.0f },
    { 1.0f, 0.0f },
    { 0.0f, 0.0f },
    { 1.0f, 1.0f },
    { 0.0f, 1.0f },
    { 0.0f, 0.0f },
    { 1.0f, 0.0f }
};

const GLuint cubeIndices[36] = {
    // 앞면
    0, 1, 2,
    2, 3, 0,
    // 뒷면
    4, 5, 6,
    6, 7, 4,
    // 왼쪽면
    1, 5, 6,
    6, 2, 1,
    // 오른쪽면
    0, 4, 7,
    7, 3, 0,
    // 윗면
    0, 1, 5,
    5, 4, 0,
    // 아랫면
    3, 2, 6,
    6, 7, 3
};
float vertices[216] = { //--- 버텍스 속성: 좌표값(FragPos), 노말값 (Normal)
-0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
 0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
 0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
 0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
-0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
-0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
-0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
 0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
 0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
 0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
-0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
-0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
-0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
-0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
-0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
-0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
-0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
-0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
 0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
 0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
 0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
 0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
 0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
 0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
-0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
 0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
 0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
 0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
-0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
-0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
-0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
 0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
 0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
 0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
-0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
-0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f
};

const GLfloat floorVertices[4][3] = {
    {50.0f, -10.0f, 50.0f },
    {-0.0f, -10.0f, 50.0f },
    {-0.0f, -10.0f, -0.0f },
    {50.0f, -10.0f, -0.0f }
};
const GLfloat floorNormal[4][3] = {
    { 0.0f, 1.0f, 0.0f },  // 정점 0
    { 0.0f, 1.0f, 0.0f },  // 정점 1
    { 0.0f, 1.0f, 0.0f },  // 정점 2
    { 0.0f, 1.0f, 0.0f }   // 정점 3
};
const GLfloat floor_color[4][3] = {
    {0.7f, 0.7f, 1.0f },
    {0.7f, 0.7f, 1.0f },
    {0.7f, 0.7f, 1.0f },
    {0.7f, 0.7f, 1.0f }
};
const GLfloat texfloor[4][2] = {
    {1.0f, 1.0f},
    {0.0f, 1.0f},
    {0.0f, 0.0f},
    {1.0f, 0.0f}
};
const GLuint sq_index[6] = {
    0,1,2,
    2,3,0
};

bool CheckOBBCollision(const OBB& A, const OBB& B)
{
    const float EPSILON = 1e-5f;
    glm::mat3 R, AbsR;

    // 회전 행렬 R[i][j] = A의 i축과 B의 j축 내적
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            R[i][j] = glm::dot(A.axis[i], B.axis[j]);

    // 두 중심 간의 벡터
    glm::vec3 t = B.center - A.center;
    // A의 로컬 좌표계로 변환
    t = glm::vec3(glm::dot(t, A.axis[0]), glm::dot(t, A.axis[1]), glm::dot(t, A.axis[2]));

    // 절댓값 행렬 (부동소수점 오차 보정)
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            AbsR[i][j] = std::fabs(R[i][j]) + EPSILON;

    float ra, rb;

    // (1) A의 세 축
    for (int i = 0; i < 3; i++) {
        ra = A.halfSize[i];
        rb = B.halfSize[0] * AbsR[i][0] + B.halfSize[1] * AbsR[i][1] + B.halfSize[2] * AbsR[i][2];
        if (std::fabs(t[i]) > ra + rb) return false;
    }

    // (2) B의 세 축
    for (int j = 0; j < 3; j++) {
        ra = A.halfSize[0] * AbsR[0][j] + A.halfSize[1] * AbsR[1][j] + A.halfSize[2] * AbsR[2][j];
        rb = B.halfSize[j];
        if (std::fabs(t[0] * R[0][j] + t[1] * R[1][j] + t[2] * R[2][j]) > ra + rb) return false;
    }

    // (3) 축의 외적 9개 (A_i × B_j)
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            ra = A.halfSize[(i + 1) % 3] * AbsR[(i + 2) % 3][j] +
                A.halfSize[(i + 2) % 3] * AbsR[(i + 1) % 3][j];
            rb = B.halfSize[(j + 1) % 3] * AbsR[i][(j + 2) % 3] +
                B.halfSize[(j + 2) % 3] * AbsR[i][(j + 1) % 3];
            float val = std::fabs(t[(i + 2) % 3] * R[(i + 1) % 3][j] -
                t[(i + 1) % 3] * R[(i + 2) % 3][j]);
            if (val > ra + rb) return false;
        }
    }

    return true; // 분리축이 없으면 충돌
}